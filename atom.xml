<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xiaonian’ Blog</title>
  
  <subtitle>As long as the ending is good,the begining is not bad.</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-12-25T09:30:52.149Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Xiaonian</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java常用类的方法</title>
    <link href="http://example.com/2020/12/25/Java%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2020/12/25/Java%E5%B8%B8%E7%94%A8%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2020-12-25T09:20:00.000Z</published>
    <updated>2020-12-25T09:30:52.149Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a><strong>Object</strong></h3><p>1.是类层次结构的根类，所有类都直接或间接的继承自object类。</p><p>2.要掌握的方法<br>A：toString()  返回对象的字符串表示<br>例 student [name = null, age = 0]<br>可以自动生成  快捷键：alt+shift+s+s</p><p>B:  equals()  比较两个对象是否相同,一般比较对象的成员变量的值是否相同。<br>例  (s1.equals(s2))  比较对象s1和对象s2的值<br>比较对象的成员变量的的时候可以自动生成 快捷键 alt+shift+s+h</p><h3 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a><strong>Scanner</strong></h3><p>1.常用格式 Scanner sc = new Scanner(System.in);</p><p>2.要掌握的两个方法<br>A.public int nextInt()<br>例：int x = sc.nextInt();<br>B.public string nextLine()<br>例 String x = sc.nextLine();</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a><strong>String</strong></h3><p>1.多个字符组成的一串数据，它可以和字符数组进行相互转换</p><p>2.构造方法：<br>public String ()  空构造<br>public String (byte[] bytes)  把字节数组转成字符串<br>public String (byte[] bytes,int offset,int length) 把字节数组的一部分转成字符串<br>public String (char[] value) 把字符数组转成字符串<br>public String (char[] value,int offset,int count) 把字符数组的一部分转成字符串<br>public String (String original) 把字符串常量值转成字符串</p><p>3.方法：<br>   判断功能<br>boolean equals(Object obj) 比较字符串的内容是否相同，区分大小写<br>例 s1.equals(s2) s1和s2比较<br>boolean equalsIgnoreCase(String str) 比较字符串内容是否相同，忽略大小写<br>例 s1.equals(s2) s1和s2比较，注意区分大小写<br>boolean contains(String str) 判断大字符串中是否包含小字符串<br>例 s1.contains(“hello”) 判断s1中有没有hello这个字符串<br>boolean startsWith(String str) 判断字符串是否以某个指定的字符串开头<br>例 s1.startWith(“h”)  判断s1中是否以h开头<br>boolean endsWith(String str) 判断字符串是否以某个指定的字符串结尾<br>例 s1.endWith(“s”)  判断s1中是否以s结尾<br>boolean isEmpty() 判断字符串是否为空<br>例 s1.isEmpty() 判断s1是否为空字符串</p><p>   获取功能<br>int length() 获取字符串的长度<br>    例 s.length()<br>char charAt(int index) 获取指定位置索引的字符<br>例 s.charAt(7) 获取第七个位置的字符(从0开始)<br>int indexOf(int ch) 返回指定字符在此字符串中第一次出现的索引<br>例 s.indexOf(“c”) 获取 c 第一次出现的位置<br>int indexOf(String str) 返回指定字符串在此字符串中第一次出现的索引<br>例 s.indexOf(“cake”) 获取 cake 第一次出现的位置<br>int indexOf(int ch,int fromIndex) 返回指定字符在此字符串中从指定位置后第一次出现处的索引<br>例 s.indexOf(“c”，4) 从第4个索引后获取 c 的索引<br>int indexOf(String str,int fromIndex) 返回指定字符串在此字符串中从指定位置后第一次出现处的索引<br>例 s.indexOf(“cake”，4) 从第4个索引后获取 cake 的索引<br>String substring(int start) 从指定位置截取字符串，默认到结尾<br>例 s.substring(5) 从第5个位置截取字符串<br>String substring(int start,int end) 从指定位置开始到结束截取字符串<br>例 s.substring(5,8) 从第5个位置截取字符串到第8个结束，不包括第8个字符。（包左不包右）</p><p>   转换功能<br>byte[] getBytes() 把字符串转换为字节数组。<br>例 byte[] bys = s.getBytes();<br>char[] toCharArray() 把字符串转换为字符数组<br>例 char[] cha = s.toCharArray();<br>static String valueOf(char[] chs) 把字符数组转成字符串。<br>例 String ss = String.valueOf(cha);<br>static String valueOf(int i) 把int类型的数据转成字符串<br>例 int y=100;<br> String s2= String.valueOf(y);<br>String toLowerCase() 把字符串转成小写<br>例 String s1=s.toLowerCase<br>String toUpperCase() 把字符串转成大写<br>例 String s1=s.toUpperCase<br>String concat(String str) 把字符串拼接<br>例 s1.concat(s2) 把s1和s2拼接</p><p>  其他功能<br>String replace(char old, char new) 替换字符串中的某一个字符<br>例 s1.replace(“p”,”u”)  把s1中的所有p字符替换成u字符<br>String replace(String old, String new) 替换字符串中的字符串<br>例 s1.replace(“hello”,”feiji”) 把s1中的hello替换成feiji<br>String trim() 去除字符串两端空格<br>例 s1.trim（）；<br>int compareTo(String str) 按字典顺序比较两 个字符串<br>例 s1.compareTo(s2);<br> 把s1和s2比较，一样返回0。<br>int compateToIgnoreCase(String str) 按字典顺序比较两个字符串，区分大小写<br>例 同上</p><h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a><strong>StringBuffer</strong></h3><p>（是同步的，数据安全，效率低）/StringBuilder(单线程使用，不同步，效率高。)<br>1.线程安全的可变字符串。</p><p>2.构造方法<br>public StringBuffer() 无参构造方法。<br>public StringBuffer(int capacity) 指定容量的字符串缓冲区对象。<br>public StringBuffer(String str) 指定字符串内容的字符串缓冲区对象。<br>3.方法<br>  A：添加功能<br>public StringBuffer append(String str)  添加任意类型到字符串杯子中<br>public StringBuffer insert(int offset,String str) 在指定位置插入任意类型的数据到杯子中</p><p>   B: 删除功能<br>public StringBuffer deleteCharAt(int index) 删除指定位置的一个字符<br>public StringBuffer delete(int start,int end) 删除指定区间的所有字符（包左不包右）</p><p>  C: 替换功能<br>public StringBuffer replace(int start,int end,String str) 替换指定区间的字符串（包左不包右）</p><p>   D: 反转功能<br>public StringBuffer reverse()  反转字符串，例 abc–cba</p><p>   E: 截取功能（注意返回值是String类型的）<br>public String substring(int start) 截掉字符串，（截掉输入参数之前的所有字符串）<br>public String substring(int start,int end) 截掉区间的字符串（包左不包右）<br>public int capacity() 返回当前容量。<br>public int length()  返回长度（字符数）。</p><h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a><strong>Arrays</strong></h3><p> 1.针对数组进行操作的的类（排序，查找…）<br> 2.方法<br>public static String toString(int[] a)  把数组转成字符串<br>public static void sort(int[] a)  对数组进行排序<br>public static int binarySearch(int[] a,int key)  二分查找（必须是排序后的数组才能查找）</p><h3 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a><strong>Integer</strong></h3><p>1.该类提供了多个方法，能在 int 类型和 String 类型之间互相转换，<br> 还提供了处理 int 类型时非常有用的其他一些常量和方法</p><p>2.构造方法<br>public Integer(int value)  把int类型转换成Integer类型<br>public Integer(String s)  把string类型转换成Integer类型（里面必须是数字）</p><p>3.方法<br>public int intValue()<br>public static int parseInt(String s)  把String类型转成int类型<br>public static String toString(int i)  把int类型转成String类型<br>public static Integer valueOf(int i)  把int类型转换成Integer类型<br>public static Integer valueOf(String s)  把string类型转换成Integer类型（里面必须是数字）</p><h3 id="Character"><a href="#Character" class="headerlink" title="Character"></a><strong>Character</strong></h3><p>1.Character 类在对象中包装一个基本类型 char 的值<br> 此外，该类提供了几种方法，以确定字符的类别（小写字母，数字，等等），并将字符从大写转换成小写，反之亦然</p><p>2.成员方法<br>public static boolean isUpperCase(char ch) 判断给定的字符是否是大写字符<br>public static boolean isLowerCase(char ch)  判断给定的字符是否是小写字符<br>public static boolean isDigit(char ch)  判断给定的字符是否是数字字符<br>public static char toUpperCase(char ch)  把给定的字符转换为大写字符<br>public static char toLowerCase(char ch) 把给定的字符转换为小写字符</p><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a><strong>Math</strong></h3><p> 1.Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。</p><p>2.成员方法<br>public static int abs(int a)  返回 int 值的绝对值。<br>public static double ceil(double a)  向上取整<br>public static double floor(double a) 向下取整<br>public static int max(int a,int b)  比较两个数的最大值<br>public static double pow(double a,double b)  a的b次幂<br>public static double random()  随机数<br>public static int round(float a) 四舍五入<br>public static double sqrt(double a)  正平方根</p><h3 id="Random"><a href="#Random" class="headerlink" title="Random"></a><strong>Random</strong></h3><p>1.此类用于产生随机数</p><p>2.构造方法<br>public Random()  没有给种子，用的是默认种子，是当前时间的毫秒值。<br>例 Random r = new Random();<br>public Random(long seed)  给出指定的种子，给出种子后每次得到的随机数是相同的<br>例 Random r = new Random(1201);</p><p>3.成员方法<br>public int nextInt() 返回的是int范围内的随机数<br>例 r.nextInt()  返回一个int范围内的随机数<br>public int nextInt(int n) 返回的是【0，n】范围内的随机数<br>例 r.nextInt(100) 返回0到100以内的随机数</p><h3 id="System"><a href="#System" class="headerlink" title="System"></a><strong>System</strong></h3><p>1.System 类包含一些有用的类字段和方法。它不能被实例化</p><p>2.成员方法</p><p>public static void gc()  垃圾回收器<br>public static void exit(int status) 终止当前正在运行的虚拟机，参数给0就可以了。<br>public static long currentTimeMillis() 以毫秒为单位返回当前时间<br>public static void arraycopy(Object src,int srcPos,Object dest,int destPos,int length)<br>数组复制<br>src - 源数组。<br>srcPos - 源数组中的起始位置。<br>dest - 目标数组。<br>destPos - 目标数据中的起始位置。<br>length - 要复制的数组元素的数量。</p><h3 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a><strong>BigInteger</strong></h3><p>1.可以让超过Integer范围内的数据进行运算</p><p>2.构造方法<br>public BigInteger(String val)</p><p>3.成员方法<br>public BigInteger add(BigInteger val) 加法<br>例  s.add(s1) s和s1相加<br>public BigInteger subtract(BigInteger val) 减法<br>public BigInteger multiply(BigInteger val) 乘法<br>public BigInteger divide(BigInteger val) 除法<br>public BigInteger[] divideAndRemainder(BigInteger val) 返回商及余数的数组</p><h3 id="BigDecimal（做小数的运算）"><a href="#BigDecimal（做小数的运算）" class="headerlink" title="BigDecimal（做小数的运算）"></a><strong>BigDecimal</strong>（做小数的运算）</h3><p>1.不可变的、任意精度的有符号十进制数<br>由于在运算的时候，float类型和double很容易丢失精度，演示案例。<br>所以，为了能精确的表示、计算浮点数，Java提供了BigDecimal</p><p>2.构造方法<br>public BigDecimal(String val)</p><p>3.方法<br>public BigDecimal add(BigDecimal augend)  加法<br>public BigDecimal subtract(BigDecimal subtrahend)  减法<br>public BigDecimal multiply(BigDecimal multiplicand)  乘法<br>public BigDecimal divide(BigDecimal divisor)  除法<br>public BigDecimal divide(BigDecimal divisor,int scale, int roundingMode)</p><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a><strong>Date</strong></h3><p>1.Date 表示特定的瞬间，精确到毫秒</p><p>2.构造方法<br>public Date() 根据当前的毫秒值创建日期对象<br>public Date(long date) 根据给定的毫秒值创建日期对象</p><p>3.成员方法<br>public long getTime()  获取当前时间<br>public void setTime(long time)  设置时间</p><h3 id="DateFormat"><a href="#DateFormat" class="headerlink" title="DateFormat"></a><strong>DateFormat</strong></h3><p>1.DateFormat 是日期/时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间。<br> 是抽象类，所以使用其子类SimpleDateFormat</p><p>2.SimpleDateFormat（可以把日期转换成String类型）</p><p>3.构造方法<br>public SimpleDateFormat() 默认模式<br>public SimpleDateFormat(String pattern)<br>SimpleDateFormat sdf = new SimpleDateFormat(“yyyy年MM月dd日 HH:mm:ss”)</p><p>4.成员方法<br>public final String format(Date date) 把日期格式转换成String类型<br>public Date parse(String source)  把给定的字符串解析成日期格式</p><h3 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a><strong>Calendar</strong></h3><p>1.Calendar 类是一个抽象类，它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等 日历字段之间的转  换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。</p><p>2.成员方法<br>public static Calendar getInstance()  获取当前时间<br>Calendar c = Calendar.getInstance;</p><p>public int get(int field) 返回给定日历字段的值。<br>public void add(int field,int amount)  根据给定的日历字段和对应的时间，来对当前的日历进行操作<br>public final void set(int year,int month,int date) 设定当前的日历时间</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Object&quot;&gt;&lt;a href=&quot;#Object&quot; class=&quot;headerlink&quot; title=&quot;Object&quot;&gt;&lt;/a&gt;&lt;strong&gt;Object&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;1.是类层次结构的根类，所有类都直接或间接的继承自object类。&lt;/p&gt;</summary>
      
    
    
    
    <category term="后端 - Java" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF-Java/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="基础" scheme="http://example.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Mysql练习50题</title>
    <link href="http://example.com/2020/12/25/Sql%E7%BB%83%E4%B9%A050%E9%A2%98/"/>
    <id>http://example.com/2020/12/25/Sql%E7%BB%83%E4%B9%A050%E9%A2%98/</id>
    <published>2020-12-25T08:53:00.000Z</published>
    <updated>2020-12-25T08:57:53.932Z</updated>
    
    <content type="html"><![CDATA[<p>– 建表<br>– 学生表<br>CREATE TABLE <code>Student</code>(<br>    <code>s_id</code> VARCHAR(20),<br>    <code>s_name</code> VARCHAR(20) NOT NULL DEFAULT ‘’,<br>    <code>s_birth</code> VARCHAR(20) NOT NULL DEFAULT ‘’,<br>    <code>s_sex</code> VARCHAR(10) NOT NULL DEFAULT ‘’,<br>    PRIMARY KEY(<code>s_id</code>)<br>);<br>– 课程表<br>CREATE TABLE <code>Course</code>(<br>    <code>c_id</code>  VARCHAR(20),<br>    <code>c_name</code> VARCHAR(20) NOT NULL DEFAULT ‘’,<br>    <code>t_id</code> VARCHAR(20) NOT NULL,<br>    PRIMARY KEY(<code>c_id</code>)<br>);<br>– 教师表<br>CREATE TABLE <code>Teacher</code>(<br>    <code>t_id</code> VARCHAR(20),<br>    <code>t_name</code> VARCHAR(20) NOT NULL DEFAULT ‘’,<br>    PRIMARY KEY(<code>t_id</code>)<br>);<br>– 成绩表<br>CREATE TABLE <code>Score</code>(<br>    <code>s_id</code> VARCHAR(20),<br>    <code>c_id</code>  VARCHAR(20),<br>    <code>s_score</code> INT(3),<br>    PRIMARY KEY(<code>s_id</code>,<code>c_id</code>)<br>);<br>– 插入学生表测试数据<br>INSERT INTO Student VALUES(‘01’ , ‘赵雷’ , ‘1990-01-01’ , ‘男’);<br>INSERT INTO Student VALUES(‘02’ , ‘钱电’ , ‘1990-12-21’ , ‘男’);<br>INSERT INTO Student VALUES(‘03’ , ‘孙风’ , ‘1990-05-20’ , ‘男’);<br>INSERT INTO Student VALUES(‘04’ , ‘李云’ , ‘1990-08-06’ , ‘男’);<br>INSERT INTO Student VALUES(‘05’ , ‘周梅’ , ‘1991-12-01’ , ‘女’);<br>INSERT INTO Student VALUES(‘06’ , ‘吴兰’ , ‘1992-03-01’ , ‘女’);<br>INSERT INTO Student VALUES(‘07’ , ‘郑竹’ , ‘1989-07-01’ , ‘女’);<br>INSERT INTO Student VALUES(‘08’ , ‘王菊’ , ‘1990-01-20’ , ‘女’);<br>– 课程表测试数据<br>INSERT INTO Course VALUES(‘01’ , ‘语文’ , ‘02’);<br>INSERT INTO Course VALUES(‘02’ , ‘数学’ , ‘01’);<br>INSERT INTO Course VALUES(‘03’ , ‘英语’ , ‘03’);</p><p>– 教师表测试数据<br>INSERT INTO Teacher VALUES(‘01’ , ‘张三’);<br>INSERT INTO Teacher VALUES(‘02’ , ‘李四’);<br>INSERT INTO Teacher VALUES(‘03’ , ‘王五’);</p><p>– 成绩表测试数据<br>INSERT INTO Score VALUES(‘01’ , ‘01’ , 80);<br>INSERT INTO Score VALUES(‘01’ , ‘02’ , 90);<br>INSERT INTO Score VALUES(‘01’ , ‘03’ , 99);<br>INSERT INTO Score VALUES(‘02’ , ‘01’ , 70);<br>INSERT INTO Score VALUES(‘02’ , ‘02’ , 60);<br>INSERT INTO Score VALUES(‘02’ , ‘03’ , 80);<br>INSERT INTO Score VALUES(‘03’ , ‘01’ , 80);<br>INSERT INTO Score VALUES(‘03’ , ‘02’ , 80);<br>INSERT INTO Score VALUES(‘03’ , ‘03’ , 80);<br>INSERT INTO Score VALUES(‘04’ , ‘01’ , 50);<br>INSERT INTO Score VALUES(‘04’ , ‘02’ , 30);<br>INSERT INTO Score VALUES(‘04’ , ‘03’ , 20);<br>INSERT INTO Score VALUES(‘05’ , ‘01’ , 76);<br>INSERT INTO Score VALUES(‘05’ , ‘02’ , 87);<br>INSERT INTO Score VALUES(‘06’ , ‘01’ , 31);<br>INSERT INTO Score VALUES(‘06’ , ‘03’ , 34);<br>INSERT INTO Score VALUES(‘07’ , ‘02’ , 89);<br>INSERT INTO Score VALUES(‘07’ , ‘03’ , 98);</p><p>– 1、查询”01”课程比”02”课程成绩高的学生的信息及课程分数<br>SELECT a.*,b.<code>s_score</code> AS 01_score,c.<code>s_score</code> AS 02_score<br>FROM student AS a INNER JOIN score AS b ON b.c_id = ‘01’ AND a.<code>s_id</code>=b.<code>s_id</code><br>INNER JOIN score AS c ON a.<code>s_id</code>=c.<code>s_id</code> AND c.<code>c_id</code>=’02’<br>WHERE b.<code>s_score</code> &gt; c.<code>s_score</code>;</p><p>– 2、查询”01”课程比”02”课程成绩低的学生的信息及课程分数<br>SELECT a.*,b.<code>s_score</code> AS 01_score,c.<code>s_score</code> AS 02_score<br>FROM student AS a INNER JOIN score AS b ON b.c_id = ‘01’ AND a.<code>s_id</code>=b.<code>s_id</code><br>INNER JOIN score AS c ON a.<code>s_id</code>=c.<code>s_id</code> AND c.<code>c_id</code>=’02’<br>WHERE b.<code>s_score</code> &lt; c.<code>s_score</code>;</p><p>– 3、查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩<br>SELECT a.<code>s_id</code>,a.<code>s_name</code>,AVG(b.<code>s_score</code>)<br>FROM student AS a INNER JOIN score AS b ON a.<code>s_id</code>=b.<code>s_id</code><br>GROUP BY a.<code>s_id</code>,a.<code>s_name</code> HAVING AVG(b.<code>s_score</code>) &gt;= 60;</p><p>– 4、查询平均成绩小于60分的同学的学生编号和学生姓名和平均成绩<br>SELECT a.<code>s_id</code>,a.<code>s_name</code>,AVG(b.<code>s_score</code>)<br>FROM student AS a INNER JOIN score AS b ON a.<code>s_id</code>=b.<code>s_id</code><br>GROUP BY a.<code>s_id</code>,a.<code>s_name</code> HAVING AVG(b.<code>s_score</code>) &lt;= 60;</p><p>– 5、查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩<br>SELECT a.<code>s_id</code> AS 学生编号,a.<code>s_name</code> AS 学生姓名,COUNT(b.<code>c_id</code>) AS 选课总数,SUM(b.<code>s_score</code>) AS 所有课程的总成绩<br>FROM student AS a INNER JOIN score AS b ON a.<code>s_id</code>=b.<code>s_id</code><br>GROUP BY a.<code>s_id</code>,a.<code>s_name</code>;</p><p>– 6、查询”李”姓老师的数量<br>SELECT COUNT(t_name) AS 数量<br>FROM teacher<br>WHERE t_name LIKE ‘李%’;</p><p>– 7、查询学过”张三”老师授课的同学的信息<br>SELECT d.*<br>FROM teacher AS a INNER JOIN course AS b ON a.<code>t_id</code>=b.<code>t_id</code><br>INNER JOIN score AS c ON b.<code>c_id</code>=c.<code>c_id</code><br>INNER JOIN student AS d ON c.<code>s_id</code>=d.<code>s_id</code><br>WHERE a.<code>t_name</code>=’张三’;</p><p>– 8、查询没学过”张三”老师授课的同学的信息<br>SELECT *<br>FROM student<br>WHERE s_id NOT IN (<br>    SELECT d.<code>s_id</code><br>    FROM teacher AS a INNER JOIN course AS b ON a.<code>t_id</code>=b.<code>t_id</code><br>    INNER JOIN score AS c ON b.<code>c_id</code>=c.<code>c_id</code><br>    INNER JOIN student AS d ON c.<code>s_id</code>=d.<code>s_id</code><br>    WHERE a.<code>t_name</code>=’张三’<br>);</p><p>– 9、查询学过编号为”01”并且也学过编号为”02”的课程的同学的信息<br>SELECT *<br>FROM student<br>WHERE s_id IN(SELECT a.<code>s_id</code><br>FROM student AS a INNER JOIN score AS b ON a.<code>s_id</code>=b.<code>s_id</code> AND b.<code>c_id</code>=’01’<br>INNER JOIN score AS c ON c.<code>s_id</code>=a.<code>s_id</code> AND c.<code>c_id</code>=’02’)</p><p>– 10、查询学过编号为”01”但是没有学过编号为”02”的课程的同学的信息<br>SELECT *<br>FROM student<br>WHERE s_id IN(SELECT a.<code>s_id</code><br>FROM student AS a INNER JOIN score AS b ON a.<code>s_id</code>=b.<code>s_id</code> AND b.<code>c_id</code>=’01’)<br>AND s_id NOT IN(SELECT a.<code>s_id</code><br>FROM student AS a INNER JOIN score AS c ON a.<code>s_id</code>=c.<code>s_id</code> AND c.<code>c_id</code>=’02’)</p><p>– 11、查询没有学全所有课程的同学的信息<br>– 解法一<br>SELECT *<br>FROM student<br>WHERE s_id NOT IN(<br>    SELECT a.<code>s_id</code><br>    FROM student AS a INNER JOIN score AS b ON a.<code>s_id</code>=b.<code>s_id</code> AND b.<code>c_id</code>=’01’<br>    INNER JOIN score AS c ON a.<code>s_id</code>=c.<code>s_id</code> AND c.<code>c_id</code>=’02’<br>    INNER JOIN score AS d ON a.<code>s_id</code>=d.<code>s_id</code> AND d.<code>c_id</code>=’03’<br>)</p><p>– 解法二<br>SELECT *<br>FROM student<br>WHERE s_id NOT IN(<br>    SELECT s_id<br>    FROM score<br>    GROUP BY s_id<br>    HAVING COUNT(c_id)=(<br>        SELECT COUNT(DISTINCT c_id) FROM course<br>    )<br>);</p><p>– 12、查询至少有一门课与学号为”01”的同学所学相同的同学的信息 *<br>– &lt;&gt;表示不等于<br>– 解法一<br>SELECT *<br>FROM student<br>WHERE s_id IN(<br>    SELECT DISTINCT a.<code>s_id</code><br>    FROM score AS a<br>    WHERE a.<code>c_id</code> IN (<br>        SELECT b.<code>c_id</code><br>        FROM score AS b<br>        WHERE b.<code>s_id</code>=’01’<br>    )<br>    AND a.<code>s_id</code> &lt;&gt; ‘01’<br>);</p><p>– 解法二<br>SELECT DISTINCT a.*<br>FROM student AS a INNER JOIN score AS b ON a.<code>s_id</code>=b.<code>s_id</code><br>WHERE b.<code>c_id</code> IN(<br>    SELECT c_id<br>    FROM score<br>    WHERE s_id=’01’<br>)<br>AND b.<code>s_id</code> &lt;&gt; ‘01’;</p><p>– 13、查询和”01”号的同学学习的课程完全相同的其他同学的信息<br>SELECT *<br>FROM student<br>WHERE s_id IN(<br>    SELECT s_id<br>    FROM score<br>    GROUP BY s_id<br>    HAVING COUNT(c_id)=(<br>        SELECT COUNT(c_id)<br>        FROM score<br>        WHERE s_id=’01’<br>    )<br>    AND s_id &lt;&gt; ‘01’<br>);</p><p>– 14、查询没学过”张三”老师讲授的任一门课程的学生姓名<br>– 解法一<br>SELECT s_name<br>FROM student<br>WHERE s_id NOT IN(<br>    SELECT s_id<br>    FROM score<br>    WHERE c_id=(<br>        SELECT c_id<br>        FROM course<br>        WHERE t_id=(<br>            SELECT t_id<br>            FROM teacher<br>            WHERE t_name=’张三’<br>        )<br>    )<br>);</p><p>– 解法二<br>SELECT s_name<br>FROM student<br>WHERE s_id NOT IN(<br>    SELECT a.<code>s_id</code><br>    FROM score AS a INNER JOIN course AS b ON a.<code>c_id</code>=b.<code>c_id</code><br>    INNER JOIN teacher AS c ON b.<code>t_id</code>=c.<code>t_id</code> AND c.<code>t_name</code>=’张三’<br>);</p><p>– 15、查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩<br>– 解法一<br>SELECT a.<code>s_id</code>,a.<code>s_name</code>,AVG(b.<code>s_score</code>) AS avg_score<br>FROM student AS a INNER JOIN score AS b ON a.<code>s_id</code>=b.<code>s_id</code><br>WHERE a.<code>s_id</code> IN (<br>    SELECT s_id<br>    FROM score<br>    WHERE s_score &lt;= ‘60’<br>    GROUP BY s_id<br>    HAVING COUNT(s_id) &gt;= ‘2’<br>)<br>GROUP BY a.<code>s_id</code>,a.<code>s_name</code>;</p><p>– 解法二<br>SELECT a.<code>s_id</code>,a.<code>s_name</code>,AVG(b.<code>s_score</code>) AS avg_score<br>FROM student AS a INNER JOIN score AS b ON a.<code>s_id</code>=b.<code>s_id</code> AND b.<code>s_score</code> &lt;= ‘60’<br>GROUP BY a.<code>s_id</code>,a.<code>s_name</code><br>HAVING COUNT(b.<code>s_score</code>) &gt;= ‘2’;</p><p>– 16、检索”01”课程分数小于60，按分数降序排列的学生信息<br>SELECT a.*<br>FROM student AS a INNER JOIN score AS b ON a.<code>s_id</code>=b.<code>s_id</code> AND b.<code>c_id</code>=’01’<br>WHERE a.<code>s_id</code> IN (<br>    SELECT s_id<br>    FROM score<br>    WHERE s_score &lt; ‘60’<br>);</p><p>– 17、按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩<br>SELECT a.*,<br>    (SELECT s_score FROM score WHERE c_id=’01’ AND s_id=b.<code>s_id</code>) AS 语文,<br>    (SELECT s_score FROM score WHERE c_id=’02’ AND s_id=b.<code>s_id</code>) AS 数学,<br>    (SELECT s_score FROM score WHERE c_id=’03’ AND s_id=b.<code>s_id</code>) AS 英语,<br>    ROUND(AVG(b.<code>s_score</code>),2) AS 平均分<br>FROM student AS a INNER JOIN score AS b ON a.<code>s_id</code>=b.<code>s_id</code><br>GROUP BY a.<code>s_id</code><br>ORDER BY ROUND(AVG(b.<code>s_score</code>),2) DESC;</p><p>– 18.查询各科成绩最高分、最低分和平均分：以如下形式显示：课程ID，课程name，最高分，最低分，平均分，及格率，中等率，优良率，优秀率–及格为&gt;=60，<br>– 中等为：70-80，优良为：80-90，优秀为：&gt;=90<br>SELECT a.<code>c_id</code> AS 课程ID,a.<code>c_name</code> AS 课程name,MAX(b.<code>s_score</code>) AS 最高分,MIN(b.<code>s_score</code>) AS 最低分,AVG(b.<code>s_score</code>) AS 平均分,<br>    ROUND(100*(SUM(CASE WHEN b.<code>s_score</code> &gt;= ‘60’ THEN 1 ELSE 0 END)/SUM(CASE WHEN b.<code>s_score</code> THEN 1 ELSE 0 END)),2) AS 及格率,<br>    ROUND(100*(SUM(CASE WHEN b.<code>s_score</code> BETWEEN 70 AND 80 THEN 1 ELSE 0 END)/SUM(CASE WHEN b.<code>s_score</code> THEN 1 ELSE 0 END)),2) AS 中等率,<br>    ROUND(100*(SUM(CASE WHEN b.<code>s_score</code> BETWEEN 80 AND 90 THEN 1 ELSE 0 END)/SUM(CASE WHEN b.<code>s_score</code> THEN 1 ELSE 0 END)),2) AS 优良率,<br>    ROUND(100*(SUM(CASE WHEN b.<code>s_score</code> &gt;= ‘90’ THEN 1 ELSE 0 END)/SUM(CASE WHEN b.<code>s_score</code> THEN 1 ELSE 0 END)),2) AS 优秀率<br>FROM course AS a INNER JOIN score AS b ON a.<code>c_id</code>=b.<code>c_id</code><br>GROUP BY a.<code>c_id</code>,a.<code>c_name</code>;</p><p>– 19、按各科成绩进行排序，并显示排名<br>– 数据库版本过低 无法使用排序函数,百度查询说需要mysql 8.0以上版本,坑爹<br>SELECT s_id, c_id, s_score, dense_rank() over(ORDER BY s_score DESC) AS rank<br>FROM score;</p><p>– 20、查询学生的总成绩并进行排名<br>SELECT s_id,SUM(s_score)<br>FROM score<br>GROUP BY s_id<br>ORDER BY SUM(s_score) DESC;</p><p>– 21、查询不同老师所教不同课程平均分从高到低显示<br>SELECT a.<code>t_id</code>,AVG(c.<code>s_score</code>)<br>FROM teacher AS a INNER JOIN course AS b ON a.<code>t_id</code>=b.<code>t_id</code><br>INNER JOIN score AS c ON b.<code>c_id</code>=c.<code>c_id</code><br>GROUP BY a.<code>t_id</code><br>ORDER BY AVG(c.<code>s_score</code>) DESC;</p><p>– 22、查询所有课程的成绩第2名到第3名的学生信息及该课程成绩<br>– limit i,n i=0时可省略 i表示索引，n表示查询条数<br>SELECT a.*,SUM(b.<code>s_score</code>)<br>FROM student AS a INNER JOIN score AS b ON a.<code>s_id</code>=b.<code>s_id</code><br>GROUP BY a.<code>s_id</code><br>ORDER BY SUM(b.<code>s_score</code>)<br>LIMIT 1,2;</p><p>– 23、统计各科成绩各分数段人数：课程编号,课程名称,[100-85],[85-70],[70-60],[0-60]及所占百分比<br>SELECT a.<code>c_id</code> AS 课程编号, a.<code>c_name</code> AS 课程名称,<br>    SUM(CASE WHEN b.<code>s_score</code> BETWEEN 85 AND 100 THEN 1 ELSE 0 END) AS one人数,<br>    ROUND(100*(SUM(CASE WHEN b.<code>s_score</code> BETWEEN 85 AND 100 THEN 1 ELSE 0 END)/SUM(CASE WHEN b.<code>s_score</code> THEN 1 ELSE 0 END)),2) AS one百分比,<br>    SUM(CASE WHEN b.<code>s_score</code> BETWEEN 70 AND 85 THEN 1 ELSE 0 END) AS two人数,<br>    ROUND(100*(SUM(CASE WHEN b.<code>s_score</code> BETWEEN 70 AND 85 THEN 1 ELSE 0 END)/SUM(CASE WHEN b.<code>s_score</code> THEN 1 ELSE 0 END)),2) AS two百分比,<br>    SUM(CASE WHEN b.<code>s_score</code> BETWEEN 60 AND 70 THEN 1 ELSE 0 END) AS three人数,<br>    ROUND(100*(SUM(CASE WHEN b.<code>s_score</code> BETWEEN 60 AND 70 THEN 1 ELSE 0 END)/SUM(CASE WHEN b.<code>s_score</code> THEN 1 ELSE 0 END)),2) AS three百分比,<br>    SUM(CASE WHEN b.<code>s_score</code> &lt; 60 THEN 1 ELSE 0 END) AS four人数,<br>    ROUND(100*(SUM(CASE WHEN b.<code>s_score</code> &lt; 60 THEN 1 ELSE 0 END)/SUM(CASE WHEN b.<code>s_score</code> THEN 1 ELSE 0 END)),2) AS four百分比<br>FROM course AS a INNER JOIN score AS b ON a.<code>c_id</code>=b.<code>c_id</code><br>GROUP BY a.<code>c_id</code>,a.<code>c_name</code>;</p><p>– 24、查询学生平均成绩及其名次<br>– mysql 版本过低 不识别rank<br>SELECT s_id,rank() over(ORDER BY AVG(s_score) DESC) AS avg_score<br>FROM score<br>GROUP BY s_id;</p><p>– 25、查询各科成绩前三名的记录<br>– union连接查询语句，列值不可重复 union all列值可重复<br>(SELECT * FROM score WHERE c_id=’01’ ORDER BY s_score DESC LIMIT 3)<br>UNION<br>(SELECT * FROM score WHERE c_id=’02’ ORDER BY s_score DESC LIMIT 3)<br>UNION<br>(SELECT * FROM score WHERE c_id=’03’ ORDER BY s_score DESC LIMIT 3);</p><p>– 26、查询每门课程被选修的学生数<br>– 聚合函数就要使用group by分组<br>SELECT c_id,COUNT(s_id)<br>FROM score<br>GROUP BY c_id;</p><p>– 27、查询出只有两门课程的全部学生的学号和姓名<br>SELECT a.<code>s_id</code> AS 学号,a.<code>s_name</code> AS 姓名<br>FROM student AS a INNER JOIN score AS b ON a.<code>s_id</code>=b.<code>s_id</code><br>GROUP BY a.<code>s_id</code><br>HAVING COUNT(b.<code>c_id</code>)=’2’;</p><p>– 28、查询男生、女生人数<br>– 解法一<br>SELECT COUNT(s_sex) AS 人数<br>FROM student<br>GROUP BY s_sex;</p><p>– 解法二<br>(SELECT s_sex,COUNT(s_sex) FROM student WHERE s_sex=’男’)<br>UNION<br>(SELECT s_sex,COUNT(s_sex) FROM student WHERE s_sex=’女’);</p><p>– 29、查询名字中含有”风”字的学生信息<br>SELECT *<br>FROM student<br>WHERE s_name LIKE ‘%风%’;</p><p>– 30、查询同名同性学生名单，并统计同名人数<br>SELECT a.<code>s_name</code>,a.<code>s_sex</code>,COUNT(*)<br>FROM student AS a INNER JOIN student AS b ON a.<code>s_id</code> &lt;&gt; b.<code>s_id</code> AND a.<code>s_name</code>=b.<code>s_name</code> AND a.<code>s_sex</code> = b.<code>s_sex</code><br>GROUP BY a.<code>s_name</code>,a.<code>s_sex</code>;</p><p>– 31、查询1990年出生的学生名单<br>SELECT * FROM student WHERE s_birth LIKE ‘1990%’;</p><p>– 32、查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列<br>SELECT c_id,AVG(s_score) AS 平均成绩<br>FROM score<br>GROUP BY c_id<br>ORDER BY AVG(s_score) DESC,c_id ASC;</p><p>– 33、查询平均成绩大于等于85的所有学生的学号、姓名和平均成绩<br>SELECT a.<code>s_id</code> AS 学号,a.<code>s_name</code> AS 姓名,AVG(b.<code>s_score</code>) AS 平均成绩<br>FROM student AS a INNER JOIN score AS b ON a.<code>s_id</code>=b.<code>s_id</code><br>GROUP BY a.<code>s_id</code>,a.<code>s_name</code><br>HAVING AVG(b.<code>s_score</code>) &gt;= ‘85’;</p><p>– 34、查询课程名称为”数学”，且分数低于60的学生姓名和分数<br>SELECT a.<code>s_name</code> AS 学生姓名,b.<code>s_score</code> AS 分数<br>FROM student AS a INNER JOIN score AS b ON a.<code>s_id</code>=b.<code>s_id</code> INNER JOIN course AS c ON b.<code>c_id</code>=c.<code>c_id</code> AND c.<code>c_name</code>=’数学’<br>WHERE b.<code>s_score</code> &lt; ‘60’;</p><p>– 35、查询所有学生的课程及分数情况；<br>SELECT b.<code>s_id</code>,b.<code>s_score</code>,a.<code>c_name</code>,a.<code>c_id</code><br>FROM course AS a INNER JOIN score AS b ON a.<code>c_id</code>=b.<code>c_id</code>;</p><p>– 36、查询任何一门课程成绩在70分以上的姓名、课程名称和分数；<br>SELECT a.<code>s_name</code> AS 姓名,c.<code>c_name</code> AS 课程名称,b.<code>s_score</code> AS 分数<br>FROM student AS a INNER JOIN score AS b ON a.<code>s_id</code>=b.<code>s_id</code> INNER JOIN course AS c ON b.<code>c_id</code>=c.<code>c_id</code><br>WHERE b.<code>s_score</code> &gt;= ‘70’;</p><p>– 37、查询不及格的课程<br>SELECT a.<code>s_name</code> AS 姓名,c.<code>c_name</code> AS 课程名称,b.<code>s_score</code> AS 分数<br>FROM student AS a INNER JOIN score AS b ON a.<code>s_id</code>=b.<code>s_id</code> INNER JOIN course AS c ON b.<code>c_id</code>=c.<code>c_id</code><br>WHERE b.<code>s_score</code> &lt; ‘60’;</p><p>– 38、查询课程编号为01且课程成绩在80分以上的学生的学号和姓名；<br>SELECT a.<code>s_id</code> AS 学号, a.<code>s_name</code> AS 姓名<br>FROM student AS a INNER JOIN score AS b ON a.<code>s_id</code>=b.<code>s_id</code> AND b.<code>c_id</code>=’01’<br>WHERE b.<code>s_score</code> &gt;= ‘80’;</p><p>– 39、求每门课程的学生人数<br>SELECT COUNT(s_id) AS 学生人数<br>FROM score<br>GROUP BY c_id;</p><p>– 40、查询选修”张三”老师所授课程的学生中，成绩最高的学生信息及其成绩<br>SELECT a.*,MAX(b.<code>s_score</code>)<br>FROM student AS a INNER JOIN score AS b ON a.<code>s_id</code>=b.<code>s_id</code><br>INNER JOIN course AS c ON b.<code>c_id</code>=c.<code>c_id</code><br>INNER JOIN teacher AS d ON c.<code>t_id</code>=d.<code>t_id</code> AND d.<code>t_name</code>=’张三’; </p><p>– 41、查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩<br>SELECT DISTINCT a.<code>s_id</code> AS 学生编号,a.<code>c_id</code> AS 课程编号,a.<code>s_score</code> AS 学生成绩<br>FROM score AS a,score AS b<br>WHERE a.<code>c_id</code> &lt;&gt; b.<code>c_id</code> AND a.<code>s_score</code>=b.<code>s_score</code>;</p><p>– 42、查询每门功成绩最好的前两名<br>(SELECT c_id,s_score FROM score WHERE c_id=’01’ ORDER BY s_score DESC LIMIT 2)<br>UNION ALL<br>(SELECT c_id,s_score FROM score WHERE c_id=’02’ ORDER BY s_score DESC LIMIT 2)<br>UNION ALL<br>(SELECT c_id,s_score FROM score WHERE c_id=’03’ ORDER BY s_score DESC LIMIT 2);</p><p>– 43、统计每门课程的学生选修人数（超过5人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列<br>SELECT c_id AS 课程号,COUNT(s_id) AS 选修人数<br>FROM score<br>GROUP BY c_id<br>HAVING COUNT(s_id)&gt;5<br>ORDER BY COUNT(s_id) DESC,c_id ASC;</p><p>– 44、检索至少选修两门课程的学生学号<br>SELECT s_id,COUNT(c_id)<br>FROM score<br>GROUP BY s_id<br>HAVING COUNT(c_id) &gt;= ‘2’;</p><p>– 45、查询选修了全部课程的学生信息<br>SELECT a.*<br>FROM student AS a INNER JOIN score AS b ON a.<code>s_id</code>=b.<code>s_id</code><br>GROUP BY a.<code>s_id</code><br>HAVING COUNT(c_id) = (SELECT COUNT(c_id) FROM course);</p><p>– 46、查询各学生的年龄 按照出生日期来算，当前月日 &lt; 出生年月的月日则，年龄减一<br>– Date_Format() 用不同格式显示日期和时间<br>– Now() 表示返回当前日期和时间<br>– %Y四位  %y二位  %m月值（00-12） %d月的天，数值(0-31)<br>SELECT s_id,s_birth,<br>(DATE_FORMAT(NOW(),’%Y’)-DATE_FORMAT(s_birth,’%Y’)-(CASE WHEN DATE_FORMAT(NOW(),’%m%d’)&gt;DATE_FORMAT(s_birth,’%m%d’) THEN 0 ELSE 1 END)) AS 年龄<br>FROM student;</p><p>– 47、查询本周过生日的学生<br>– WEEK表示周<br>SELECT *<br>FROM student<br>WHERE WEEK(DATE_FORMAT(NOW(),’%Y%m%d’))=WEEK(s_birth);</p><p>– 48、查询下周过生日的学生<br>SELECT *<br>FROM student<br>WHERE WEEK(DATE_FORMAT(NOW(),’%Y%m%d’))+1=WEEK(s_birth);</p><p>– 49、查询本月过生日的学生<br>– MONTH表示月<br>SELECT *<br>FROM student<br>WHERE MONTH(DATE_FORMAT(NOW(),’%Y%m%d’))=MONTH(s_birth);</p><p>– 50、查询下月<code>score</code>过生日的学生<br>SELECT *<br>FROM student<br>WHERE MONTH(DATE_FORMAT(NOW(),’%Y%m%d’))+1=MONTH(s_birth);</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;– 建表&lt;br&gt;– 学生表&lt;br&gt;CREATE TABLE &lt;code&gt;Student&lt;/code&gt;(&lt;br&gt;    &lt;code&gt;s_id&lt;/code&gt; VARCHAR(20),&lt;br&gt;    &lt;code&gt;s_name&lt;/code&gt; VARCHAR(20) NOT NULL</summary>
      
    
    
    
    <category term="后端 - Mysql" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF-Mysql/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
    <category term="Mysql" scheme="http://example.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化</title>
    <link href="http://example.com/2020/12/25/Redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://example.com/2020/12/25/Redis%E6%8C%81%E4%B9%85%E5%8C%96/</id>
    <published>2020-12-25T08:41:00.000Z</published>
    <updated>2020-12-25T08:46:51.162Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Redis持久化RDB和AOF"><a href="#Redis持久化RDB和AOF" class="headerlink" title="Redis持久化RDB和AOF"></a>Redis持久化RDB和AOF</h3><p>​    Redis性能好，读写快，单线程，是一个内存型数据库，Nosql非关系型数据库</p><pre><code>RDB——数据快照Redis可以加载RDB文件，将数据从磁盘读取到数据库Redis中。Redis目录中有一个dump.rdb文件，是一个二进制文件。在Redis中，自动保存RDB是默认开启的。RDB优缺点：(1)优点：1.RDB是某一个时间节点的快照，是一个紧凑的单文件，更多用于数据备份。2.单文件容易传输到远程服务器做故障恢复3.RDB可以子进程Fork进行持久化，使Redis更好处理用户请求4.在大量数据情况下，RDB比AOF更快加载(2)缺点：1.如果Redis不及时保存RDB文件，会造成数据的丢失2.RDB经常需要使用子进程Fork，而Fork操作会消耗大量CPU资源AOF——日志追加AOF相当于一个操作的日志记录，默认是关闭的，在redis.conf中配置开启，会看到appendonly.aof文件缺点会导致文件数据冗余，可进行日志重写。(1)优点：1.AOF可以设置完全不同步，每秒同步，每次操作同步，默认每秒同步2.若AOF文件过大，Redis会自动重写AOF文件，消除数据冗余3.AOF有序保存数据库的所有写入操作，易读易分析。(2)缺点：1.相同数据量情况下，AOF文件通常比RDB文件大2.在大量写入和载入的时候，AOF比RDB文件效率低。不推荐单独使用AOF，因为AOF对于数据的恢复载入来说，比RDB慢。AOF和RDB可以一起使用。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Redis持久化RDB和AOF&quot;&gt;&lt;a href=&quot;#Redis持久化RDB和AOF&quot; class=&quot;headerlink&quot; title=&quot;Redis持久化RDB和AOF&quot;&gt;&lt;/a&gt;Redis持久化RDB和AOF&lt;/h3&gt;&lt;p&gt;​    Redis性能好，读写快，</summary>
      
    
    
    
    <category term="后端 - Redis" scheme="http://example.com/categories/%E5%90%8E%E7%AB%AF-Redis/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
</feed>
